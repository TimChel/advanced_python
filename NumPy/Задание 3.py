import numpy as np
import matplotlib.pyplot as plt
# Рассмотрим сложную математическую функцию на отрезке [1, 15]:
#
# f(x) = sin(x / 5) * exp(x / 10) + 5 * exp(-x / 2)
#
# Она может описывать, например, зависимость оценок, которые выставляют определенному сорту вина эксперты, в зависимости
# от возраста этого вина. Мы хотим приблизить сложную зависимость с помощью функции из определенного семейства. В этом
# задании мы будем приближать указанную функцию с помощью многочленов.
#
# Как известно, многочлен степени n (то есть w0 + w1x + w2x2 + … + wnxn) однозначно определяется любыми n + 1 различными
# точками, через которые он проходит. Это значит, что его коэффициенты w0, … wn можно определить из следующей системы
# линейных уравнений:
#
# Воспользуемся описанным свойством, и будем находить приближение функции многочленом, решая систему линейных уравнений.
#
# 1. Сформируйте систему линейных уравнений (то есть задайте матрицу коэффициентов A и свободный вектор b) для
# многочлена первой степени, который должен совпадать с функцией f в точках 1 и 15. Решите данную систему с помощью
# функции scipy.linalg.solve. Нарисуйте функцию f и полученный многочлен. Хорошо ли он приближает исходную функцию?
# 2. Повторите те же шаги для многочлена второй степени, который совпадает с функцией f в точках 1, 8 и 15. Улучшилось
# ли качество аппроксимации?
# 3. Повторите те же шаги для многочлена третьей степени, который совпадает с функцией f в точках 1, 4, 10 и 15. Хорошо
# ли он аппроксимирует функцию? Коэффициенты данного многочлена (четыре числа в следующем порядке: w_0, w_1, w_2, w_3)
# являются ответом на задачу. Округлять коэффициенты не обязательно, но при желании можете произвести округление до
# второго знака (т.е. до числа вида 0.42)
def f(x):
    return np.sin(x / 5) * np.exp(x / 10) + 5 * np.exp(-x / 2)

def pogreshnost(x, y):
    return np.sum(abs(x + y))/x.size

x_plt = np.arange(1, 15, 0.1)
plt.plot(x_plt, f(x_plt))

A1 = np.array([[1, 1], [1,15]])
b1 = np.array(f(np.array([1, 15])))
w1 = np.linalg.solve(A1, b1)
plt.plot(x_plt, w1[0] + w1[1]*x_plt)

A2 = np.array([[1, 1, 1], [1, 8, 8**2], [1, 15, 15**2]])
b2 = np.array(f(np.array([1, 8, 15])))
w2 = np.linalg.solve(A2, b2)
plt.plot(x_plt, w2[0] + w2[1]*x_plt + w2[2]*x_plt**2)

A3 = np.array([[1, 1, 1, 1], [1, 4, 4**2, 4**3], [1, 10, 10**2, 10**3], [1, 15, 15**2, 15**3]])
b3 = np.array(f(np.array([1, 4, 10, 15])))
w3 = np.linalg.solve(A3, b3)
plt.plot(x_plt, w3[0] + w3[1]*x_plt + w3[2]*x_plt**2 + w3[3]*x_plt**3)
plt.legend(['Функция', 'Линейное приближение', 'Квадратичное приближение', 'Кубическое приближение'])


print('Как можно заметить, кубическая функция лучше приближает исходную, чем линейная и квадратная функции.\n'
      'Коэффициненты многочлена 3-ей степени:\n', *[round(elem, 2) for elem in w3])

plt.show()